#pragma once

#include "process.hpp"
#include <atomic>
#include <chrono>
#include <condition_variable>
#include <functional>
#include <mutex>
#include <optional>
#include <tuple>
#include <vector>

enum class TaskStatus {
  uninitialized = 0,
  waiting,
  running,
  completed,
};

enum class Interrupt { taskInit = 0, taskComplete, taskRestart, taskAdded };

enum class SchedulingAlgo { EDF = 0, RMS };

class Scheduler; // Forward declaration

class Task {
private:
  ProcType proc;
  TaskStatus status = TaskStatus::uninitialized;
  Interrupt onWake = Interrupt::taskInit;
  std::chrono::milliseconds period;
  std::chrono::milliseconds duration;
  std::chrono::milliseconds runTime{0};
  std::chrono::steady_clock::time_point nextInterrupt;
  std::chrono::steady_clock::time_point deadline;
  std::chrono::steady_clock::time_point refPoint;

public:
  Task(long period, long duration,
       std::chrono::steady_clock::time_point nextInterrupt, ProcType proc);
  void run(std::chrono::steady_clock::duration dur);

  // Allow Scheduler access to private members
  friend class Scheduler;

  // Getter for validation in tests
  ProcType getType() const { return proc; }
  long getPeriodMs() const { return period.count(); }
};

class Scheduler {
public:
  // Using atomic boolean to control the loop exit
  std::atomic<bool> running{true};

  std::vector<Task> tasks;
  std::mutex queMTX;
  std::condition_variable queCV;
  std::vector<std::tuple<long, long, long, ProcType>> incoming;

  std::chrono::steady_clock timer;
  std::chrono::steady_clock::time_point startTime;
  std::chrono::steady_clock::time_point latestCP;

  std::optional<int> runTaskIndex;
  std::optional<std::tuple<int, Interrupt>> firedInterrupt;

  SchedulingAlgo algo = SchedulingAlgo::EDF;

  // The interface callback
  std::function<void(Event)> eventInterface;

  Scheduler();
  ~Scheduler();

  // Core API
  void
  initTasks(std::vector<std::tuple<long, long, long, ProcType>> paramVector);
  void loop(); // The main loop to be run in a thread
  void stop(); // Signal loop to exit

private:
  void handleTaskQ();
  void addTask(std::tuple<long, long, long, ProcType> &taskParam);
  std::tuple<std::chrono::steady_clock::time_point, int, Interrupt>
  nextInterrupt();
  void handleInterrupt(std::tuple<int, Interrupt> firedInterrupt);
  void selectRunner();
};